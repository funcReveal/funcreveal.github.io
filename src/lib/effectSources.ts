/**
 * ðŸš€ Auto-generated. Do not edit manually.
 */
export interface EffectSource {
  tsxCode: string;
  cssCode: string;
  githubUrl: string;
  TSXName: string;
  CSSName: string;
}

export const effectSources: Record<string, EffectSource> = {
  "animated-border": {
    tsxCode:
      "import React from 'react';\r\nimport styles from './AnimatedBorder.module.css';\r\n\r\n/**\r\n * AnimatedBorder Component\r\n * ------------------------\r\n * Renders a circular placeholder with a rotating colorful glow ring behind it.\r\n * This is commonly used for avatars or badges with visual effects.\r\n */\r\nconst AnimatedBorder = () => {\r\n    return (\r\n        <div className={styles.container}>\r\n            {/* Colorful rotating glow behind the circle */}\r\n            <div className={styles.glow}></div>\r\n\r\n            {/* Foreground placeholder (can represent avatar) */}\r\n            <div className={styles.placeholder}></div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default AnimatedBorder;\r\n",
    cssCode:
      "/* =====================================\r\n   Container for the Circular Glow Effect\r\n   ===================================== */\r\n.container {\r\n  position: relative;\r\n  width: 160px;\r\n  height: 160px;\r\n  border-radius: 50%; /* Make the shape circular */\r\n  display: flex;\r\n  justify-content: center; /* Horizontally center the child */\r\n  align-items: center; /* Vertically center the child */\r\n}\r\n\r\n/* ==========================================\r\n   Rotating Rainbow Glow Effect (Outer Layer)\r\n   ========================================== */\r\n.glow {\r\n  position: absolute;\r\n  top: -12px;\r\n  left: -12px;\r\n  width: calc(100% + 24px); /* Expand beyond the container */\r\n  height: calc(100% + 24px);\r\n  border-radius: 50%; /* Keep it circular */\r\n  /* Rainbow gradient effect */\r\n  background: conic-gradient(red, orange, yellow, green, blue, purple, red);\r\n  filter: blur(12px); /* Soft blur for glow effect */\r\n  animation: spin 4s linear infinite; /* Infinite spinning animation */\r\n  z-index: 1; /* Positioned below the placeholder */\r\n}\r\n\r\n/* =====================================\r\n   Placeholder Circle (Simulated Avatar)\r\n   ===================================== */\r\n.placeholder {\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 50%; /* Circular shape */\r\n  background-color: #ef9c9c; /* Default inner fill (can be replaced) */\r\n  position: relative;\r\n  z-index: 2; /* Layered above the glow */\r\n}\r\n\r\n/* ======================\r\n   Keyframe: Spin Motion\r\n   ====================== */\r\n@keyframes spin {\r\n  0% {\r\n    transform: rotate(0deg);\r\n  }\r\n  100% {\r\n    transform: rotate(360deg);\r\n  }\r\n}\r\n",
    githubUrl:
      "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/animated-border",
    TSXName: "AnimatedBorder.tsx",
    CSSName: "AnimatedBorder.module.css",
  },
  "breathing-light": {
    tsxCode:
      "import React from 'react';\r\nimport styles from './BreathingLight.module.css';\r\n\r\ninterface BreathingLightProps {\r\n    /** Diameter in px (default 24) */\r\n    size?: number;\r\n    /** Base glow color (default #00e5ff) */\r\n    color?: string;\r\n    /** Breathing cycle in seconds (default 3) */\r\n    duration?: number;\r\n}\r\n\r\nconst BreathingLight: React.FC<BreathingLightProps> = ({\r\n    size = 24,\r\n    color = '#00e5ff',\r\n    duration = 3,\r\n}) => {\r\n    // Pass CSSÂ variables to the style prop.\r\n    const style: React.CSSProperties & Record<string, string> = {\r\n        '--size': `${size}px`,\r\n        '--color': color,\r\n        '--duration': `${duration}s`,\r\n    };\r\n    return <span className={styles.breathingLight} style={style} />;\r\n};\r\n\r\nexport default BreathingLight;",
    cssCode:
      ".breathingLight {\r\n  /* Default CSSÂ variables (override via inline style) */\r\n  --size: 24px; /* Diameter of the circle */\r\n  --color: #00e5ff; /* Base glow color */\r\n  --duration: 3s; /* One breathing cycle */\r\n\r\n  width: var(--size);\r\n  height: var(--size);\r\n  background: var(--color);\r\n  border-radius: 50%;\r\n  display: inline-block;\r\n  box-shadow: 0 0 8px currentColor;\r\n  animation: breathing var(--duration) ease-in-out infinite;\r\n}\r\n\r\n@keyframes breathing {\r\n  0%,\r\n  100% {\r\n    transform: scale(0.9);\r\n    opacity: 0.6;\r\n    box-shadow: 0 0 6px currentColor, 0 0 12px currentColor;\r\n  }\r\n  50% {\r\n    transform: scale(1.2);\r\n    opacity: 1;\r\n    box-shadow: 0 0 12px currentColor, 0 0 24px currentColor;\r\n  }\r\n}\r\n",
    githubUrl:
      "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/breathing-light",
    TSXName: "BreathingLight.tsx",
    CSSName: "BreathingLight.module.css",
  },
  "falling-particles": {
    tsxCode:
      "import React, { useRef, useEffect, useMemo } from 'react';\r\n\r\n// Import particle image assets\r\nimport heart from './assets/heart.png';\r\nimport maple from './assets/maple.png';\r\nimport snowflake from './assets/snowflake.png';\r\nimport bubble from './assets/bubble.png';\r\nimport rain from './assets/rain.png';\r\nimport snow from './assets/snow.png';\r\nimport carnation from './assets/carnation.png';\r\n\r\nimport styles from './FallingParticles.module.css';\r\n\r\n// Props interface for the FallingParticles component\r\ninterface FallingParticlesProps {\r\n    count?: number; // Number of particles\r\n    speedRange?: [number, number]; // Particle falling speed range\r\n    sizeRange?: [number, number]; // Particle size range\r\n    type?: 'heart' | 'maple' | 'rain' | 'bubble' | 'snow' | 'snowflake' | 'carnation' | 'all';\r\n    opacity?: number; // Particle transparency (0 to 1)\r\n    angleInitial?: number; // Starting rotation angle\r\n    rotateSwingRange?: number; // Maximum angle of swing rotation\r\n    rotateSpeed?: number; // Speed of the swing rotation\r\n    driftAmount?: number; // Max drift per frame\r\n    tiltWithDrift?: boolean; // Whether particles tilt with drift direction\r\n    textOverlay?: string; // Optional text overlay on the canvas\r\n    background?: string; // Canvas background style\r\n}\r\n\r\n// Map each type to an image asset\r\nconst particleImageMap = {\r\n    heart,\r\n    maple,\r\n    snowflake,\r\n    snow,\r\n    bubble,\r\n    rain,\r\n    carnation,\r\n};\r\n\r\n// Particle object structure\r\ninterface Particle {\r\n    x: number;\r\n    y: number;\r\n    speed: number;\r\n    size: number;\r\n    img: HTMLImageElement;\r\n    driftX: number;\r\n    angle: number;\r\n    baseAngle: number;\r\n    angleRange: number;\r\n    angleSpeed: number;\r\n    angleTime: number;\r\n    textOverlay?: string;\r\n}\r\n\r\n// Default settings per particle type\r\nconst getDefaultsByType = (type: string) => {\r\n    switch (type) {\r\n        case 'rain': return { count: 50, tiltWithDrift: true, speedRange: [4, 5], sizeRange: [10, 20], opacity: 1, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.3 };\r\n        case 'heart': return { count: 20, tiltWithDrift: false, speedRange: [0.1, 1], sizeRange: [50, 100], opacity: 0.52, rotateSwingRange: 15, rotateSpeed: 0.015, driftAmount: 0.2 };\r\n        case 'maple': return { count: 50, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [24, 48], opacity: 0.8, rotateSwingRange: 45, rotateSpeed: 0.03, driftAmount: 0.01 };\r\n        case 'bubble': return { count: 50, tiltWithDrift: false, speedRange: [0.3, 0.8], sizeRange: [10, 20], opacity: 0.8, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.5 };\r\n        case 'carnation': return { count: 30, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n        case 'snow': return { count: 50, tiltWithDrift: false, speedRange: [0.4, 0.6], sizeRange: [8, 16], opacity: 0.2, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.5 };\r\n        case 'snowflake': return { count: 50, tiltWithDrift: false, speedRange: [0.4, 0.6], sizeRange: [15, 30], opacity: 0.2, rotateSwingRange: 0, rotateSpeed: 0, driftAmount: 0.4 };\r\n        default: return { count: 50, tiltWithDrift: false, speedRange: [0.2, 1], sizeRange: [40, 80], opacity: 1, rotateSwingRange: 15, rotateSpeed: 0.010, driftAmount: 0.1 };\r\n    }\r\n}\r\n\r\n// Random number helper\r\nconst randomBetween = (min: number, max: number) => {\r\n    return min + Math.random() * (max - min);\r\n}\r\n\r\n// Convert degrees to radians\r\nconst degToRad = (deg: number) => {\r\n    return (deg * Math.PI) / 180;\r\n}\r\n\r\n// Map value from one range to another\r\nconst mapValue = (value: number, inMin: number, inMax: number, outMin: number, outMax: number) => {\r\n    const ratio = (value - inMin) / (inMax - inMin);\r\n    return outMin + ratio * (outMax - outMin);\r\n}\r\n\r\nconst initCanvas = async (canvas: HTMLCanvasElement, container: HTMLDivElement, type: keyof typeof particleImageMap | 'all', imageStore: React.MutableRefObject<HTMLImageElement[]>) => {\r\n    // Set canvas size to match container\r\n    const resizeCanvas = () => {\r\n        canvas.width = container.offsetWidth;\r\n        canvas.height = container.offsetHeight;\r\n    };\r\n    resizeCanvas();\r\n\r\n    // Load images for the selected particle type(s)\r\n    const resolvedTypes: (keyof typeof particleImageMap)[] =\r\n        type === 'all'\r\n            ? Object.keys(particleImageMap) as (keyof typeof particleImageMap)[]\r\n            : [type];\r\n\r\n    const imageSources = resolvedTypes.map(t => particleImageMap[t]);\r\n    const imgs = await Promise.all(imageSources.map(src => new Promise<HTMLImageElement>((resolve, reject) => {\r\n        const img = new Image();\r\n        img.src = typeof src === 'string' ? src : src.src;\r\n        img.onload = () => resolve(img);\r\n        img.onerror = reject;\r\n    })));\r\n\r\n    imageStore.current = imgs;\r\n};\r\n\r\nconst FallingParticles: React.FC<FallingParticlesProps> = (props) => {\r\n    const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n    const containerRef = useRef<HTMLDivElement | null>(null);\r\n    const particlesRef = useRef<Particle[]>([]); // Store live particles\r\n    const animationRef = useRef<number | null>(null); // For canceling animation frame\r\n    const imagesRef = useRef<HTMLImageElement[]>([]); // Loaded images\r\n\r\n    const prevTypeRef = useRef<string>(''); // Track last type to know when to re-init\r\n    const isReadyRef = useRef<boolean>(false); // Prevent drawing before resources are ready\r\n\r\n    // Merge incoming props with type-specific defaults\r\n    const mergedProps = useMemo(() => {\r\n        const type = props.type ?? 'carnation';\r\n        const defaults = getDefaultsByType(type);\r\n        return {\r\n            type,\r\n            count: props.count ?? defaults.count,\r\n            speedRange: props.speedRange ?? defaults.speedRange,\r\n            sizeRange: props.sizeRange ?? defaults.sizeRange,\r\n            opacity: props.opacity ?? defaults.opacity,\r\n            rotate: props.rotateSpeed ?? defaults.rotateSpeed > 0,\r\n            drift: props.driftAmount ?? defaults.driftAmount > 0,\r\n            angleInitial: props.angleInitial ?? 0,\r\n            rotateSwingRange: props.rotateSwingRange ?? defaults.rotateSwingRange,\r\n            rotateSpeed: props.rotateSpeed ?? defaults.rotateSpeed,\r\n            driftAmount: props.driftAmount ?? defaults.driftAmount,\r\n            tiltWithDrift: props.tiltWithDrift ?? defaults.tiltWithDrift,\r\n            textOverlay: props.textOverlay,\r\n            background: props.background ?? 'transparent',\r\n        };\r\n    }, [props]);\r\n\r\n\r\n    // Keep updated text overlay\r\n    const textOverlayRef = useRef(mergedProps.textOverlay);\r\n    useEffect(() => {\r\n        textOverlayRef.current = mergedProps.textOverlay;\r\n    }, [props.textOverlay, mergedProps.textOverlay]);\r\n\r\n\r\n    // Re-init canvas and reset particles if type changed\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        const container = containerRef.current;\r\n        if (!canvas || !container) return;\r\n\r\n        if (prevTypeRef.current !== mergedProps.type) {\r\n            isReadyRef.current = false;\r\n            initCanvas(canvas, container, mergedProps.type, imagesRef).then(() => {\r\n                particlesRef.current = []; // Clear all particles on type switch\r\n                prevTypeRef.current = mergedProps.type;\r\n                isReadyRef.current = true;\r\n            });\r\n        }\r\n    }, [mergedProps.type]);\r\n\r\n\r\n\r\n    // Animation loop: add new particles over time and update existing ones\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        const container = containerRef.current;\r\n        if (!canvas || !container) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        const resizeCanvas = () => {\r\n            canvas.width = container.offsetWidth;\r\n            canvas.height = container.offsetHeight;\r\n        };\r\n        resizeCanvas();\r\n\r\n        let frameCount = 0;\r\n        const spawnInterval = 5; // Every N frames, add a new particle (adjust for appearance speed)\r\n\r\n        const animate = () => {\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n            for (const p of particlesRef.current) {\r\n                // Movement logic\r\n                p.y += p.speed;\r\n                if (mergedProps.drift) p.x += p.driftX;\r\n\r\n                // Rotation logic\r\n                if (mergedProps.rotate) {\r\n                    p.angleTime += p.angleSpeed;\r\n                    p.angle = p.baseAngle + Math.sin(p.angleTime) * p.angleRange;\r\n                }\r\n\r\n                // Draw particle\r\n                ctx.save();\r\n                ctx.globalAlpha = mergedProps.opacity;\r\n                ctx.filter = 'blur(1px)';\r\n\r\n                if (mergedProps.rotate || mergedProps.tiltWithDrift) {\r\n                    ctx.translate(p.x + p.size / 2, p.y + p.size / 2);\r\n                    let totalAngle = 0;\r\n                    if (mergedProps.rotate) totalAngle += p.angle;\r\n                    if (mergedProps.tiltWithDrift) totalAngle += Math.atan2(-p.driftX, p.speed);\r\n                    ctx.rotate(totalAngle);\r\n                    ctx.translate(-p.size / 2, -p.size / 2);\r\n                    ctx.drawImage(p.img, 0, 0, p.size, p.size);\r\n                } else {\r\n                    ctx.drawImage(p.img, p.x, p.y, p.size, p.size);\r\n                }\r\n\r\n                ctx.restore();\r\n            }\r\n\r\n            // Add new particle\r\n            frameCount++;\r\n            const currentCount = particlesRef.current.length;\r\n            const targetCount = mergedProps.count;\r\n            const canAdd = isReadyRef.current && imagesRef.current.length > 0;\r\n            if (canAdd && currentCount < targetCount && frameCount % spawnInterval === 0) {\r\n                const img = imagesRef.current[Math.floor(Math.random() * imagesRef.current.length)];\r\n                const speed = randomBetween(mergedProps.speedRange[0], mergedProps.speedRange[1]);\r\n                const size = randomBetween(mergedProps.sizeRange[0], mergedProps.sizeRange[1]);\r\n                const angleRange = degToRad(mapValue(speed, mergedProps.speedRange[0], mergedProps.speedRange[1], mergedProps.rotateSwingRange, 5));\r\n                const angleSpeed = mapValue(speed, mergedProps.speedRange[0], mergedProps.speedRange[1], mergedProps.rotateSpeed, 0.005);\r\n\r\n                particlesRef.current.push({\r\n                    x: Math.random() * canvas.width,\r\n                    y: -size - Math.random() * 100, // Random vertical offset above top edge\r\n                    speed,\r\n                    size,\r\n                    img,\r\n                    driftX: mergedProps.drift ? randomBetween(-mergedProps.driftAmount, mergedProps.driftAmount) : 0,\r\n                    angle: degToRad(mergedProps.angleInitial),\r\n                    baseAngle: degToRad(mergedProps.angleInitial),\r\n                    angleRange: mergedProps.rotate ? angleRange : 0,\r\n                    angleSpeed: mergedProps.rotate ? angleSpeed : 0,\r\n                    angleTime: Math.random() * Math.PI * 2,\r\n                });\r\n            }\r\n\r\n            // Remove off-screen particles\r\n            particlesRef.current = particlesRef.current.filter(p =>\r\n                !(p.y > canvas.height || p.x < -p.size || p.x > canvas.width + p.size)\r\n            );\r\n\r\n            // Optional text overlay\r\n            const overlayText = textOverlayRef.current;\r\n            if (overlayText) {\r\n                ctx.save();\r\n                ctx.font = '24px sans-serif';\r\n                ctx.fillStyle = 'rgba(0,0,0,0.7)';\r\n                ctx.textAlign = 'center';\r\n                ctx.fillText(overlayText, canvas.width / 2, 50);\r\n                ctx.restore();\r\n            }\r\n\r\n            // Continue animation\r\n            animationRef.current = requestAnimationFrame(animate);\r\n        };\r\n\r\n        if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n        animationRef.current = requestAnimationFrame(animate);\r\n\r\n        return () => {\r\n            if (animationRef.current !== null) cancelAnimationFrame(animationRef.current);\r\n            particlesRef.current = [];\r\n        };\r\n    }, [\r\n        mergedProps.count,\r\n        mergedProps.speedRange,\r\n        mergedProps.sizeRange,\r\n        mergedProps.opacity,\r\n        mergedProps.rotate,\r\n        mergedProps.drift,\r\n        mergedProps.angleInitial,\r\n        mergedProps.rotateSwingRange,\r\n        mergedProps.rotateSpeed,\r\n        mergedProps.driftAmount,\r\n        mergedProps.tiltWithDrift,\r\n        mergedProps.background\r\n    ]);\r\n\r\n    return (\r\n        <div className={styles.container} ref={containerRef}>\r\n            <canvas\r\n                ref={canvasRef}\r\n                style={{\r\n                    position: 'relative',\r\n                    width: '100%',\r\n                    height: '100%',\r\n                    pointerEvents: 'none',\r\n                    background: mergedProps.background,\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default FallingParticles;",
    cssCode:
      ".container {\r\n  position: relative; /* Allows the canvas inside to be absolutely positioned relative to this box */\r\n  width: 100%; /* Fixed width of the particle area */\r\n  height: 100%; /* Fixed height of the particle area */\r\n  overflow: hidden; /* Hide any particles that fall outside the box */\r\n  border: 1px solid #ccc; /* Light gray border for visibility */\r\n  border-radius: 30px; /* Rounded corners for a soft look */\r\n  z-index: 1; /* Ensure this container stays above default layers */\r\n}\r\n",
    githubUrl:
      "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/falling-particles",
    TSXName: "FallingParticles.tsx",
    CSSName: "FallingParticles.module.css",
  },
  "glow-button": {
    tsxCode:
      "import React from 'react';\r\nimport styles from './GlowButton.module.css'; // You can also use styled-components or Emotion\r\n\r\n/**\r\n * GlowButton Component\r\n * ---------------------\r\n * A button with a glowing hover effect using CSS animation.\r\n * Suitable for call-to-action or interactive UI elements.\r\n */\r\nconst GlowButton = () => {\r\n    return (\r\n        <button className={styles.glowButton}>\r\n            Hover Me\r\n        </button>\r\n    );\r\n};\r\n\r\nexport default GlowButton;\r\n",
    cssCode:
      "/* =============================\r\n   Glowing Button with Hover Effect\r\n   ============================= */\r\n.glowButton {\r\n  padding: 1rem 2rem; /* Inner spacing */\r\n  font-size: 1rem; /* Text size */\r\n  border: none; /* Remove default border */\r\n  background: #111; /* Dark background */\r\n  color: white; /* Text color */\r\n  cursor: pointer; /* Show pointer on hover */\r\n  position: relative;\r\n  border-radius: 8px; /* Rounded corners */\r\n\r\n  /* Initial glow effect (both outer and inner) */\r\n  box-shadow: 0 0 10px #00f, /* Outer glow */ 0 0 20px #00f inset; /* Inner glow */\r\n\r\n  transition: box-shadow 0.3s ease; /* Smooth transition on hover */\r\n}\r\n\r\n/* =============================\r\n   Stronger glow on hover\r\n   ============================= */\r\n.glowButton:hover {\r\n  box-shadow: 0 0 20px #0ff, /* Stronger outer glow */ 0 0 30px #0ff inset; /* Stronger inner glow */\r\n}\r\n",
    githubUrl:
      "https://github.com/funcReveal/effects-gallery/tree/main/interactive-effects/glow-button",
    TSXName: "GlowButton.tsx",
    CSSName: "GlowButton.module.css",
  },
  "shutter-effect": {
    tsxCode:
      "import React, { useState } from 'react'\r\nimport styles from './ShutterEffect.module.css'\r\n\r\nconst ShutterEffect = () => {\r\n    const [open, setOpen] = useState(false)\r\n\r\n    return (\r\n        <div\r\n            className={`${styles['shutter-container']} ${open ? styles.open : ''}`}\r\n            onClick={() => setOpen(!open)}\r\n        >\r\n            {[...Array(8)].map((_, i) => (\r\n                <div key={i} className={`${styles['shutter-blade']} ${styles[`blade-${i + 1}`]}`} />\r\n            ))}\r\n            <div className={styles['center-circle']} />\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ShutterEffect\r\n",
    cssCode:
      ".shutter-container {\r\n  position: relative;\r\n  width: 200px;\r\n  height: 200px;\r\n  background: black;\r\n  overflow: hidden;\r\n  cursor: pointer;\r\n  border-radius: 50%;\r\n}\r\n\r\n.shutter-blade {\r\n  position: absolute;\r\n  width: 50%;\r\n  height: 50%;\r\n  background: #222;\r\n  transform-origin: center center;\r\n  transition: transform 0.6s ease;\r\n}\r\n\r\n.center-circle {\r\n  position: absolute;\r\n  width: 30px;\r\n  height: 30px;\r\n  background: black;\r\n  border-radius: 50%;\r\n  top: 50%;\r\n  left: 50%;\r\n  transform: translate(-50%, -50%);\r\n  z-index: 10;\r\n}\r\n\r\n.blade-1 {\r\n  transform: rotate(0deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-2 {\r\n  transform: rotate(45deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-3 {\r\n  transform: rotate(90deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-4 {\r\n  transform: rotate(135deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-5 {\r\n  transform: rotate(180deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-6 {\r\n  transform: rotate(225deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-7 {\r\n  transform: rotate(270deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n.blade-8 {\r\n  transform: rotate(315deg) translateY(-100%);\r\n  top: 50%;\r\n  left: 50%;\r\n}\r\n\r\n.open .shutter-blade {\r\n  transform: scale(0);\r\n}\r\n",
    githubUrl:
      "https://github.com/funcReveal/effects-gallery/tree/main/static-effects/shutter-effect",
    TSXName: "ShutterEffect.tsx",
    CSSName: "ShutterEffect.module.css",
  },
};
